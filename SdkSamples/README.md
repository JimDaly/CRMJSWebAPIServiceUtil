# CRM JavaScript Web API Service Utility Samples

The **SdkSamples** project is a TypeScript project which contains four samples that correspond to
the operations performed by the [Web API Samples](https://msdn.microsoft.com/en-us/library/mt742425.aspx) in the SDK.

For each sample I've included a little commentary about how the generated library is used in TypeScript.
> Although I don't refer to the JavaScript files generated from TypeScript, it is worth looking at them if
you don't use TypeScript. **You don't have to use TypeScript!** You can use the usual methods to enjoy some level of IntelliSense with only the 
generated JavaScript library. But it isn't as robust as TypeScript. See [JavaScript IntelliSense](https://msdn.microsoft.com/en-us/library/bb385682.aspx)

## In this README
* [Common files](#common-files)
* [Basic Operations Sample](#basic-operations-sample)
* [Conditional Operations Sample](#conditional-operations-sample)
* [Functions and Actions Sample](#functions-and-actions-ample)
* [Query Data Sample](#query-data-sample)

## Common files
All the samples in this project depend on a common set of files:
* **Sdk.Sample.WebAPISamples.js**: This is the library generated by the JavaScript Web API Service Utility. 
It would be a JScript web resource with the name `sdk_/sdksample/Sdk.Sample.WebAPISamples.js`.
    * The **Sdk.Sample.WebAPISamples_Definition.json** file is the library definition for this library.
* **Sdk.Sample.WebAPISamples.d.ts**: This is the TypeScript definition file generated by the JavaScript Web API Service Utility
to describe the interfaces for the functionality included in **Sdk.Sample.WebAPISamples.js**.
* **app.css**: This is just the default CSS file provided by a TypeScript project. 
It would be a CSS web resource named `sdk_/sdksample/app.css`.

[Go to Top](#in-this-readme)
## Basic Operations Sample
This sample implements the operations detailed in the 
[Web API Basic Operations Sample](https://msdn.microsoft.com/en-us/library/mt770366.aspx).
You can compare it to the 
[Web API Basic Operations Sample (Client-side JavaScript)](https://msdn.microsoft.com/en-us/library/mt770365.aspx)
sample.
### File List
* **BasicOperations.html**: The HTML page which would be a web resource named `sdk_/sdksample/BasicOperations.html`
* **BasicOperations.js** The JavaScript library generated by TypeScript based on **BasicOperations.ts**.  
It would be a JScript web resource named `sdk_/sdksample/BasicOperations.js`
* **BasicOperations.ts** This is the TypeScript library used to write the sample. 

### Remarks
* The long `Sdk.Sample` namespace is mitigated by setting a local variable within a function (line 16):
`var ns = Sdk.Sample;` and afterwards it is referred to only using the alias `ns`.
* Notice the different ways the entity constructor is used to instantiate entity instances.
    * From a uri (line 36): `contact1 = new ns.contact(uri); //URI to constructor`
    * From JSON in a response (line 54): `contact1 = new ns.contact(response); //JSON to constructor`
* The first retrieve operation (line 47) leverages the **getUri** and **getColumnSet** methods as parameters to the **retrieve** method:
```typescript
            return ns.retrieve(
                contact1.getUri(),
                contact1.getColumnSet(),
                null, true
            );
```
* After using **retrieveTypedEntity** in TypeScript you must tell TypeScript what the type is (line 81),
But this 'hint' doesn't get included in the generated JavaScript file.
```typescript
contact1 = <Sdk.Sample.contact>response; //Need to tell TypeScript that this is a specific type.
```


* Notice the use of the property metadata (line 139):
```typescript
contact1.getFormattedValue(contact1.properties.annualincome.name) //Could also just use "annualincome"
```
 > Each entity has a **properties**, **lookups**, and **collections** property which contains metadata for the 
corresponding properties included in the library. Each of these properties has a **name** and **type** property
where the name is the string and type is the data type. The idea is that you can use auto-complete with this
to ensure that you get the name right. Once you have the name, you can simplify to a string if you wish.
* Notice the use of the entity class with JSON passed to the constructor when a *deep insert* operation is 
performed (line 150):
```typescript
            contact2.Contact_Tasks = [
                new ns.task({
                    subject: "Sign invoice",
                    description: "Invoice #12321",
                    scheduledend: new Date("April 19th, 2017")
                }),
                new ns.task({
                    subject: "Setup new display",
                    description: "Theme is - Spring is in the air",
                    scheduledstart: new Date("4/21/2017")
                }),
                new ns.task({
                    subject: "Conduct training",
                    description: "Train team on making our new blended coffee",
                    scheduledstart: new Date("6/1/2017")
                })
            ];
```
>This is required because the **Contact_Tasks** collection-valued navigation property will verify that these
objects being added to the collection are actually instances of the **Sdk.Sample.task** class.
* Notice how you must construct the string to define the expansion of navigation properties (Line 234):
```typescript
            //Get collection of contacts related to account2
            return ns.retrieve(
                account2.getUri(),
                ["name"],
                ["contact_customer_accounts($select=" + contact2.getColumnSet().join() + ")"],
                true
            );
```
> The **navProperties** properties of **retrieve** requires a string array which can include just the name of the navigation property. 
But if you don't explicitly set the **$select** it will return all properties by default.
* At the end of the sample any created records are deleted using a final **then** after the **catch**. This serves as a kind of **finally** catch
regardless of any errors that might occur in the sample, this **then** will still be called.
Since this loops through an array of Uris and deletes them, I've noticed an occasional Generic SQL error. 
This function appears to mitigate this by slowing down the 
requests with 100MS gap in between:
```typescript
.then(function () {
            //always do this
            console.log("\n--Section 5 started--");
            if (deleteData) {
                entitiesToDelete.forEach(function (uri, i) {

                    //Spacing out the deletion operations by 100 ms to avoid Generic SQL error
                    setTimeout(function (uri) {
                        ns.deleteEntity(uri)
                            .then(function () {
                                console.log("entity deleted at: %s", uri);
                            })
                            .catch(function (err) {
                                console.log("Error deleting entity at: %s \n\t Reason: %s", uri, err.message);
                            })
                    }, i * 100, uri);

                });
            }
        })
```

[Go to Top](#in-this-readme)
## Conditional Operations Sample
This sample implements the operations detailed in the 
[Web API Conditional Operations Sample](https://msdn.microsoft.com/en-us/library/mt742427.aspx).
You can compare it to the 
[Web API Conditional Operations Sample (Client-side JavaScript)](https://msdn.microsoft.com/en-us/library/mt742428.aspx)
sample.
### File List
* **ConditionalOperations.html**: The HTML page which would be a web resource named `sdk_/sdksample/ConditionalOperations.html`
* **ConditionalOperations.js** The JavaScript library generated by TypeScript based on **ConditionalOperations.ts**.  
It would be a JScript web resource named `sdk_/sdksample/ConditionalOperations.js`
* **ConditionalOperations.ts** This is the TypeScript library used to write the sample. 

### Remarks
* The entity class has a **getVersion** which will return
the ETag version number of any record retrieved and instantiated in a class.
* The **retrieve** method has an optional **version** parameter which will cause a 304 (Note modified)
response and will return `null` when the record hasn't changed.
* The **deleted** (or **deleteEntity**) method has an optional **version** which will throw an error when the entity to delete has been updated since it was last retrieved.
* The **update** method has an optional  **cancelWhenOlder** boolean parameter which will cancel the operation when the 
corresponding entity on the server has been updated since it was retrieved. The **update** method will never accidentally create a 
a new entity because it will apply the `req.setRequestHeader("If-Match", "*");` header unless **cancelWhenOlder** is specfied, which has the same effect.
* The **upsert** method has an optional boolean **preventUpdate** parameter which controls whether to allow the upsert operation to update existing records. Default is false 

[Go to Top](#in-this-readme)
## Functions and Actions Sample
This sample implements the operations detailed in the 
[Web API Functions and Actions Sample](https://msdn.microsoft.com/en-us/library/mt770368.aspx).
You can compare it to the 
[Web API Functions and Actions Sample (Client-side JavaScript)](https://msdn.microsoft.com/en-us/library/mt742429.aspx)
sample.
### File List
* **FunctionsAndActions.html**: The HTML page which would be a web resource named `sdk_/sdksample/FunctionsAndActions.html`
* **FunctionsAndActions.js** The JavaScript library generated by TypeScript based on **FunctionsAndActions.ts**.  
It would be a JScript web resource named `sdk_/sdksample/FunctionsAndActions.js`
* **FunctionsAndActions.ts** This is the TypeScript library used to write the sample. 

### Remarks
> **Important**: This sample will only work when the managed solution included in the 
[Web API Functions and Actions Sample (Client-side JavaScript)](https://msdn.microsoft.com/en-us/library/mt742429.aspx)
sample is installed in your environment. This managed solution provides the custom **sample_AddNoteToContact** and **sample_CreateCustomer** 
custom actions that are called in this sample.
* This sample demonstrates how the Web API Functions and Actions are converted to JavaScript functions and any necessary complex types or enums 
returned or required are included in the generated library.
* The **getUsersFullName** function simply shows a composed function that includes the **WhoAmI** function with a retrieve operation to return
results in a single function:
```typescript
/**
 * @function Sdk.getUsersFullName
 * @description Retrieves the current user's full name.
 * @returns A Promise that returns the full name of the user
 */
function getUsersFullName() {
    var ns = Sdk.Sample;
    return new Promise(function (resolve, reject) {
        ns.WhoAmI()
            .then(function (response: Sdk.Sample.WhoAmIResponse) {
                var myId = response.UserId;
                return ns.retrieveProperty("/systemusers(" + myId+")", "fullname");
            })
            .then(function (value) {
                resolve(value);
            })
            .catch(function (err) {
                reject("Error in getUsersFullName function: " + err.message);
            });
    });
}
```
* When you call a function which returns a complex type you will need to define what type it is within the anonymous function within the 
**then** using the full namespace. See Line 53:
```typescript
            return ns.GetTimeZoneCodeByLocalizedName("Pacific Standard Time", 1033)
        })
        .then(function (response: Sdk.Sample.GetTimeZoneCodeByLocalizedNameResponse) {
            console.log("\tFunction returned time zone %s, with code '%s'.", "Pacific Standard Time", response.TimeZoneCode);
```
> Because the **Sdk.Sample.GetTimeZoneCodeByLocalizedNameResponse** complex type is automatically included in the library, 
you don't need to look it up to see it has a **TimeZoneCode** property.
* The call to the **sample_CreateCustomer** custom action on line 137 is intended to fail by passing incorrect
parameters. This just shows how custom error messages defined within a custom action are passed back to the user.
* At line 289 within one of the functions that creates required records, you can see an example of using
the entity **set** method. I hadn't included the task **statecode** or **statuscode** properties in my library, but rather 
than update the library, I just used the **set** method. This also provides an example of using **Promise.all** to control
the flow so it only proceeds after all the **update** operations finish.
```typescript
                // An array to hold a set of promises.
                var promises = [];
                // The data to use to update the tasks so that they are closed.

                taskReferences.forEach(function (tr) {
                    var task = new ns.task(tr);
                    //statecode and statuscode are not defined in the library, so using set
                    task.set("statecode", 1);//Completed
                    task.set("statuscode", 5);//Completed
                    promises.push(ns.update(task));
                })
                return Promise.all(promises);
```
## Query Data Sample
This sample implements the operations detailed in the 
[Web API Query Data  Sample](https://msdn.microsoft.com/en-us/library/mt770367.aspx).
You can compare it to the 
[Web API Query Data Sample (Client-side JavaScript)](https://msdn.microsoft.com/en-us/library/mt742431.aspx)
sample.
### File List
* **QueryData.html**: The HTML page which would be a web resource named `sdk_/sdksample/QueryData.html`
* **QueryData.js** The JavaScript library generated by TypeScript based on **QueryData.ts**.  
It would be a JScript web resource named `sdk_/sdksample/QueryData.js`
* **QueryData.ts** This is the TypeScript library used to write the sample. 

### Remarks
* On line 16 you can see how a class can be initialized with JSON representing all the related data to complete a 
*deep insert* operation when the entity is created down on line 109.
* On line 154 you can see the use of the entity *entitySetName* property when constructing a query:
```typescript
            let filter = "&$filter=contains(fullname,'(sample)')";
            return ns.query(
                contact.entitySetName,
                "$select=" + contactProperties.join() + filter,
                true);
```
>In this case it is using an existing contact instance which just happens to be available, but if there isn't one
available you could also just 'new up' an instance in case you don't happen to know that the entity set 
name of contact entity is `contacts`. Of course if you know the string value, you should just use that:
```typescript
    let filter = "&$filter=contains(fullname,'(sample)')";
            return ns.query(
                new ns.contact().entitySetName,
                "$select=" + contactProperties.join() + filter,
                true);
```
* On line 166 you can see an example of using one of the Microsoft CRM Query functions. 
```typescript
            let filter = "&$filter=Microsoft.Dynamics.CRM.LastXHours(PropertyName='createdon',PropertyValue='1')";
            return ns.query(contact.entitySetName,
                "$select=" + contactProperties.join() + filter,
                true
            );
```
> I haven't gotten around to creating a helper function for this, but I think it will be pretty straightforward, 
in the generated library, something like:
```javascript
    this.qf.LastXHours = function(propertyName,propertyValue){
        return "Microsoft.Dynamics.CRM.LastXHours(PropertyName='"+propertyName+"',PropertyValue='"+propertyValue+"')";

    }
```
> I think it would be good to put these within a container like `qf` because there are so many of them. Then the query would look like this:
```typescript
            let filter = "&$filter="+ns.qf.LastXHours('createdon','1');
            return ns.query(contact.entitySetName,
                "$select=" + contactProperties.join() + filter,
                true
            );
```
> If you want this, let me know.
* on line 287 you can see the **getNextPage** function in use:
```typescript
        .then(function (results) {
            let count = results.count;
            let maxPages = Math.ceil(count / 4);
            console.log(
                "Contacts total: %s \tContacts per page: %s.\tOutputting first 2 pages.",
                count,
                4
            );
            output(
                results.value.map(function (x) { return new ns.contact(x) }),
                "Page 1 of " + maxPages + ":",
                contactProperties
            );

            return ns.getNextPage(results.nextLink, true, 4);

        })
        .then(function (results) {
            let count = results.count;
```
> This shows how the return value of a query is modeled as a **entityCollection** object which has three properties: 
**value**, **nextLink**, and **count**. This helps mitigate the fact that the OData properties *@odata.nextLink** 
and **@odata.count** don't play well with IntelliSense due to the `@` character.
* Line 345 shows how the results of a collection can be instantiated in one line using the **map** function of an array.
```typescript
            return ns.retrieve(
                contact.getUri(),
                contactProperties,
                ["account_primary_contact($select=" + accountProperties.join() + ")"],
                true
            );
        })
        .then(function (entity) {
            var contact = new ns.contact(entity);
            var label = "Contact '" + contact.fullname + "' is the primary contact for the following accounts:";
            output(
                contact.account_primary_contact.map(function (x) { return new ns.account(x) }),
                label,
                accountProperties
            );
```
> Although this sample doesn't use it, this could be applied to the **value** property of results returned.
* Finally, the sample ends up with a couple examples using **executeFetch**. For example, at line 420:
```typescript
            let page = 3;
            let count = 4;
            var fetchXML = "<fetch mapping=\"logical\" page=\"" + page +"\" count=\""+count+"\"> \
  <entity name=\"contact\"> \
    <attribute name=\"fullname\" /> \
    <attribute name=\"jobtitle\" /> \
    <attribute name=\"annualincome\" /> \
    <order descending=\"true\" attribute=\"fullname\" /> \
    <filter type=\"and\"> \
      <condition value=\"%(sample)%\" attribute=\"fullname\" operator=\"like\" /> \
    </filter> \
  </entity> \
</fetch> ";

            return ns.executeFetch(
                contact.entitySetName,
                fetchXML,
                true);
        })
```
